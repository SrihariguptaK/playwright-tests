json
{
  "success": true,
  "playwrightTests": [
    {
      "storyId": "story-19",
      "storyTitle": "As Scheduler, I want the conflict resolution interface to support filtering and sorting of conflicts to prioritize my work effectively",
      "testFile": "conflict-resolution-filtering-sorting.spec.ts",
      "testCode": "import { test, expect } from '@playwright/test';\n\ntest.describe('Conflict Resolution Interface - Filtering and Sorting', () => {\n  test.beforeEach(async ({ page }) => {\n    // Navigate to conflict resolution interface before each test\n    await page.goto('/conflict-resolution');\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('Verify filtering by date, resource, and severity (happy-path)', async ({ page }) => {\n    // Apply date range filter\n    await page.click('[data-testid=\"date-range-filter\"]');\n    await page.fill('[data-testid=\"start-date-input\"]', '01/01/2024');\n    await page.fill('[data-testid=\"end-date-input\"]', '01/15/2024');\n    await page.click('[data-testid=\"apply-date-filter\"]');\n    \n    // Wait for filtered results to load\n    await page.waitForResponse(response => \n      response.url().includes('/api/conflicts') && response.status() === 200\n    );\n    \n    // Verify conflicts within date range are displayed\n    const conflictsAfterDateFilter = await page.locator('[data-testid=\"conflict-item\"]').count();\n    expect(conflictsAfterDateFilter).toBeGreaterThan(0);\n    \n    // Verify date range is applied\n    const displayedDates = await page.locator('[data-testid=\"conflict-date\"]').allTextContents();\n    for (const dateText of displayedDates) {\n      const conflictDate = new Date(dateText);\n      expect(conflictDate >= new Date('2024-01-01') && conflictDate <= new Date('2024-01-15')).toBeTruthy();\n    }\n    \n    // Clear date filter and apply resource filter\n    await page.click('[data-testid=\"clear-date-filter\"]');\n    await page.click('[data-testid=\"resource-filter-dropdown\"]');\n    await page.click('[data-testid=\"resource-option-conference-room-a\"]');\n    await page.click('[data-testid=\"apply-resource-filter\"]');\n    \n    // Wait for filtered results\n    await page.waitForResponse(response => \n      response.url().includes('/api/conflicts') && response.status() === 200\n    );\n    \n    // Verify conflicts related to selected resource are shown\n    const resourceConflicts = await page.locator('[data-testid=\"conflict-resource\"]').allTextContents();\n    for (const resource of resourceConflicts) {\n      expect(resource).toContain('Conference Room A');\n    }\n    \n    // Clear resource filter and apply severity filter\n    await page.click('[data-testid=\"clear-resource-filter\"]');\n    await page.click('[data-testid=\"severity-filter-dropdown\"]');\n    await page.click('[data-testid=\"severity-option-high\"]');\n    await page.click('[data-testid=\"apply-severity-filter\"]');\n    \n    // Wait for filtered results\n    await page.waitForResponse(response => \n      response.url().includes('/api/conflicts') && response.status() === 200\n    );\n    \n    // Verify conflicts matching severity are displayed\n    const severityBadges = await page.locator('[data-testid=\"conflict-severity\"]').allTextContents();\n    for (const severity of severityBadges) {\n      expect(severity.toLowerCase()).toContain('high');\n    }\n    \n    // Verify conflict count matches filter criteria\n    const finalConflictCount = await page.locator('[data-testid=\"conflict-item\"]').count();\n    const displayedCount = await page.locator('[data-testid=\"conflict-count\"]').textContent();\n    expect(displayedCount).toContain(finalConflictCount.toString());\n  });\n\n  test('Test sorting by priority and creation time (happy-path)', async ({ page }) => {\n    // Sort by priority descending\n    await page.click('[data-testid=\"priority-column-header\"]');\n    \n    // Wait for sorted results\n    await page.waitForTimeout(1000);\n    \n    // Verify conflicts are ordered from highest to lowest priority\n    const prioritiesDescending = await page.locator('[data-testid=\"conflict-priority\"]').allTextContents();\n    \n    // Verify first 3 conflicts are High priority\n    for (let i = 0; i < Math.min(3, prioritiesDescending.length); i++) {\n      expect(prioritiesDescending[i].toLowerCase()).toContain('high');\n    }\n    \n    // Scroll to bottom and verify last conflicts are Low priority\n    await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));\n    const lastConflicts = await page.locator('[data-testid=\"conflict-priority\"]').last().textContent();\n    expect(lastConflicts?.toLowerCase()).toContain('low');\n    \n    // Scroll back to top\n    await page.evaluate(() => window.scrollTo(0, 0));\n    \n    // Sort by creation time ascending\n    await page.click('[data-testid=\"creation-time-column-header\"]');\n    await page.waitForTimeout(1000);\n    \n    // Verify conflicts are ordered from oldest to newest\n    const creationTimesAscending = await page.locator('[data-testid=\"conflict-creation-time\"]').allTextContents();\n    \n    // Verify first conflict has earliest creation date\n    const firstDate = new Date(creationTimesAscending[0]);\n    expect(firstDate).toBeInstanceOf(Date);\n    \n    // Verify last conflict has most recent creation date\n    const lastDate = new Date(creationTimesAscending[creationTimesAscending.length - 1]);\n    expect(lastDate >= firstDate).toBeTruthy();\n    \n    // Verify chronological order\n    for (let i = 0; i < creationTimesAscending.length - 1; i++) {\n      const currentDate = new Date(creationTimesAscending[i]);\n      const nextDate = new Date(creationTimesAscending[i + 1]);\n      expect(nextDate >= currentDate).toBeTruthy();\n    }\n    \n    // Toggle to descending order\n    await page.click('[data-testid=\"creation-time-column-header\"]');\n    await page.waitForTimeout(1000);\n    \n    // Verify order is now descending\n    const creationTimesDescending = await page.locator('[data-testid=\"conflict-creation-time\"]').allTextContents();\n    const firstDescDate = new Date(creationTimesDescending[0]);\n    const lastDescDate = new Date(creationTimesDescending[creationTimesDescending.length - 1]);\n    expect(firstDescDate >= lastDescDate).toBeTruthy();\n  });\n\n  test('Ensure filter input validation and feedback (error-case)', async ({ page }) => {\n    // Enter invalid date format\n    await page.click('[data-testid=\"date-range-filter\"]');\n    await page.fill('[data-testid=\"start-date-input\"]', '99/99/9999');\n    await page.click('[data-testid=\"apply-date-filter\"]');\n    \n    // Verify validation error is displayed\n    const invalidFormatError = page.locator('[data-testid=\"date-validation-error\"]');\n    await expect(invalidFormatError).toBeVisible();\n    await expect(invalidFormatError).toContainText('Invalid date format');\n    \n    // Clear and enter invalid date range (end before start)\n    await page.fill('[data-testid=\"start-date-input\"]', '01/15/2024');\n    await page.fill('[data-testid=\"end-date-input\"]', '01/01/2024');\n    await page.click('[data-testid=\"apply-date-filter\"]');\n    \n    // Verify validation error for invalid range\n    const invalidRangeError = page.locator('[data-testid=\"date-validation-error\"]');\n    await expect(invalidRangeError).toBeVisible();\n    await expect(invalidRangeError).toContainText('End date must be after start date');\n    \n    // Enter future date range\n    await page.fill('[data-testid=\"start-date-input\"]', '01/01/2025');\n    await page.fill('[data-testid=\"end-date-input\"]', '12/31/2025');\n    await page.click('[data-testid=\"apply-date-filter\"]');\n    \n    // Wait for response\n    await page.waitForResponse(response => \n      response.url().includes('/api/conflicts') && response.status() === 200\n    );\n    \n    // Verify no conflicts or appropriate message for future dates\n    const noConflictsMessage = page.locator('[data-testid=\"no-conflicts-message\"]');\n    const conflictCount = await page.locator('[data-testid=\"conflict-item\"]').count();\n    \n    if (conflictCount === 0) {\n      await expect(noConflictsMessage).toBeVisible();\n    }\n    \n    // Clear filters and apply valid filters\n    await page.click('[data-testid=\"clear-all-filters\"]');\n    await page.click('[data-testid=\"date-range-filter\"]');\n    await page.fill('[data-testid=\"start-date-input\"]', '01/01/2024');\n    await page.fill('[data-testid=\"end-date-input\"]', '01/31/2024');\n    \n    // Select valid resource\n    await page.click('[data-testid=\"resource-filter-dropdown\"]');\n    await page.click('[data-testid=\"resource-option-conference-room-a\"]');\n    \n    // Select valid severity\n    await page.click('[data-testid=\"severity-filter-dropdown\"]');\n    await page.click('[data-testid=\"severity-option-high\"]');\n    \n    // Apply all filters\n    await page.click('[data-testid=\"apply-all-filters\"]');\n    \n    // Wait for filtered results\n    await page.waitForResponse(response => \n      response.url().includes('/api/conflicts') && response.status() === 200\n    );\n    \n    // Verify no validation errors\n    await expect(page.locator('[data-testid=\"date-validation-error\"]')).not.toBeVisible();\n    \n    // Verify conflict count and displayed conflicts match criteria\n    const validFilteredCount = await page.locator('[data-testid=\"conflict-item\"]').count();\n    const displayedCount = await page.locator('[data-testid=\"conflict-count\"]').textContent();\n    expect(displayedCount).toContain(validFilteredCount.toString());\n    \n    // Verify all displayed conflicts match filter criteria\n    const conflictDates = await page.locator('[data-testid=\"conflict-date\"]').allTextContents();\n    const conflictResources = await page.locator('[data-testid=\"conflict-resource\"]').allTextContents();\n    const conflictSeverities = await page.locator('[data-testid=\"conflict-severity\"]').allTextContents();\n    \n    for (let i = 0; i < validFilteredCount; i++) {\n      const conflictDate = new Date(conflictDates[i]);\n      expect(conflictDate >= new Date('2024-01-01') && conflictDate <= new Date('2024-01-31')).toBeTruthy();\n      expect(conflictResources[i]).toContain('Conference Room A');\n      expect(conflictSeverities[i].toLowerCase()).toContain('high');\n    }\n  });\n});"
    }
  ]
}