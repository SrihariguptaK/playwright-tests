json
{
  "success": true,
  "playwrightTests": [
    {
      "storyId": "story-12",
      "storyTitle": "As Scheduler, I want the system to detect scheduling conflicts within 2 seconds to enable immediate action",
      "testFile": "scheduling-conflict-detection.spec.ts",
      "testCode": "import { test, expect } from '@playwright/test';\n\ntest.describe('Story-12: Scheduling Conflict Detection Performance', () => {\n  const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';\n  const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000/api';\n\n  test.beforeEach(async ({ page }) => {\n    // Navigate to scheduling interface\n    await page.goto(`${BASE_URL}/scheduling`);\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('Verify conflict detection within 2 seconds (happy-path)', async ({ page }) => {\n    // Step 1: Navigate to the scheduling interface and note the current timestamp\n    await expect(page.locator('[data-testid=\"scheduling-interface\"]')).toBeVisible();\n    \n    // Step 2: Create a new booking entry that overlaps with an existing booking\n    await page.click('[data-testid=\"create-booking-button\"]');\n    await page.fill('[data-testid=\"booking-resource-input\"]', 'Conference Room A');\n    await page.fill('[data-testid=\"booking-start-time\"]', '2024-01-15T10:00');\n    await page.fill('[data-testid=\"booking-end-time\"]', '2024-01-15T11:00');\n    \n    // Record timestamp before submission\n    const submissionTime = Date.now();\n    await page.click('[data-testid=\"submit-booking-button\"]');\n    \n    // Wait for conflict notification and measure response time\n    const conflictNotification = page.locator('[data-testid=\"conflict-notification\"]');\n    await conflictNotification.waitFor({ state: 'visible', timeout: 3000 });\n    const detectionTime = Date.now();\n    const responseTime = detectionTime - submissionTime;\n    \n    // Verify detection occurred within 2 seconds\n    expect(responseTime).toBeLessThan(2000);\n    await expect(conflictNotification).toContainText('scheduling conflict detected');\n    \n    // Step 3: Update booking to create resource over-allocation\n    await page.click('[data-testid=\"close-notification\"]');\n    await page.click('[data-testid=\"bookings-list\"]');\n    await page.click('[data-testid=\"booking-item\"]:first-child');\n    await page.click('[data-testid=\"edit-booking-button\"]');\n    \n    // Modify to create over-allocation\n    await page.fill('[data-testid=\"booking-resource-quantity\"]', '15');\n    const updateSubmissionTime = Date.now();\n    await page.click('[data-testid=\"update-booking-button\"]');\n    \n    // Monitor for conflict detection notification\n    await conflictNotification.waitFor({ state: 'visible', timeout: 3000 });\n    const updateDetectionTime = Date.now();\n    const updateResponseTime = updateDetectionTime - updateSubmissionTime;\n    \n    expect(updateResponseTime).toBeLessThan(2000);\n    await expect(conflictNotification).toContainText('resource over-allocation');\n    \n    // Step 4: Access conflict logs and verify recordings\n    await page.goto(`${BASE_URL}/conflicts/logs`);\n    await page.waitForLoadState('networkidle');\n    \n    const conflictLogs = page.locator('[data-testid=\"conflict-log-entry\"]');\n    await expect(conflictLogs).toHaveCount(2, { timeout: 5000 });\n    \n    // Verify first conflict log entry\n    const firstLogEntry = conflictLogs.nth(0);\n    await expect(firstLogEntry).toContainText('Conference Room A');\n    await expect(firstLogEntry.locator('[data-testid=\"conflict-timestamp\"]')).toBeVisible();\n    await expect(firstLogEntry.locator('[data-testid=\"conflict-type\"]')).toContainText('overlapping time slot');\n    \n    // Verify second conflict log entry\n    const secondLogEntry = conflictLogs.nth(1);\n    await expect(secondLogEntry.locator('[data-testid=\"conflict-timestamp\"]')).toBeVisible();\n    await expect(secondLogEntry.locator('[data-testid=\"conflict-type\"]')).toContainText('resource over-allocation');\n    \n    // Verify metadata presence\n    await expect(firstLogEntry.locator('[data-testid=\"booking-id\"]')).toBeVisible();\n    await expect(firstLogEntry.locator('[data-testid=\"resource-name\"]')).toBeVisible();\n  });\n\n  test('Test detection under concurrent scheduling inputs (edge-case)', async ({ page, context }) => {\n    // Step 1: Set up simulation environment for concurrent sessions\n    const concurrentSessions = 7;\n    const pages = [page];\n    \n    // Create additional browser pages for concurrent sessions\n    for (let i = 1; i < concurrentSessions; i++) {\n      const newPage = await context.newPage();\n      await newPage.goto(`${BASE_URL}/scheduling`);\n      await newPage.waitForLoadState('networkidle');\n      pages.push(newPage);\n    }\n    \n    // Step 2: Simultaneously create multiple overlapping bookings\n    const bookingPromises = [];\n    const submissionTimes: number[] = [];\n    const detectionTimes: number[] = [];\n    \n    for (let i = 0; i < pages.length; i++) {\n      const currentPage = pages[i];\n      \n      const bookingPromise = (async () => {\n        await currentPage.click('[data-testid=\"create-booking-button\"]');\n        await currentPage.fill('[data-testid=\"booking-resource-input\"]', 'Meeting Room B');\n        await currentPage.fill('[data-testid=\"booking-start-time\"]', '2024-01-16T14:00');\n        await currentPage.fill('[data-testid=\"booking-end-time\"]', '2024-01-16T15:30');\n        \n        const submitTime = Date.now();\n        submissionTimes.push(submitTime);\n        \n        await currentPage.click('[data-testid=\"submit-booking-button\"]');\n        \n        // Monitor for conflict detection\n        const notification = currentPage.locator('[data-testid=\"conflict-notification\"]');\n        await notification.waitFor({ state: 'visible', timeout: 3000 });\n        \n        const detectTime = Date.now();\n        detectionTimes.push(detectTime);\n        \n        return { submitTime, detectTime };\n      })();\n      \n      bookingPromises.push(bookingPromise);\n    }\n    \n    // Wait for all concurrent bookings to complete\n    const results = await Promise.all(bookingPromises);\n    \n    // Step 3: Verify detection time for each conflict\n    results.forEach((result, index) => {\n      const latency = result.detectTime - result.submitTime;\n      expect(latency).toBeLessThan(2000);\n    });\n    \n    // Step 4: Access system performance metrics\n    await page.goto(`${BASE_URL}/admin/performance`);\n    await page.waitForLoadState('networkidle');\n    \n    const avgDetectionLatency = page.locator('[data-testid=\"avg-detection-latency\"]');\n    await expect(avgDetectionLatency).toBeVisible();\n    \n    const latencyValue = await avgDetectionLatency.textContent();\n    const latencyMs = parseInt(latencyValue?.replace(/[^0-9]/g, '') || '0');\n    expect(latencyMs).toBeLessThan(2000);\n    \n    // Step 5: Review conflict logs for completeness\n    await page.goto(`${BASE_URL}/conflicts/logs`);\n    await page.waitForLoadState('networkidle');\n    \n    // Expected conflicts: concurrentSessions - 1 (first booking succeeds, rest conflict)\n    const expectedConflicts = concurrentSessions - 1;\n    const conflictLogs = page.locator('[data-testid=\"conflict-log-entry\"]');\n    \n    // Wait for all conflicts to be logged\n    await page.waitForTimeout(1000);\n    const logCount = await conflictLogs.count();\n    expect(logCount).toBeGreaterThanOrEqual(expectedConflicts);\n    \n    // Step 6: Verify all conflicts are identified accurately\n    for (let i = 0; i < Math.min(logCount, expectedConflicts); i++) {\n      const logEntry = conflictLogs.nth(i);\n      await expect(logEntry.locator('[data-testid=\"conflict-type\"]')).toContainText('overlapping');\n      await expect(logEntry.locator('[data-testid=\"resource-name\"]')).toContainText('Meeting Room B');\n      await expect(logEntry.locator('[data-testid=\"conflict-timestamp\"]')).toBeVisible();\n      await expect(logEntry.locator('[data-testid=\"booking-id\"]')).toBeVisible();\n    }\n    \n    // Verify no conflicts were missed by checking system completeness indicator\n    const completenessIndicator = page.locator('[data-testid=\"conflict-detection-completeness\"]');\n    await expect(completenessIndicator).toContainText('100%');\n    \n    // Clean up additional pages\n    for (let i = 1; i < pages.length; i++) {\n      await pages[i].close();\n    }\n  });\n});"
    }
  ]
}